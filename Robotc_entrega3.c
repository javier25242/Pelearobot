#pragma config(Sensor, S1,     sonic,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     sengirp,        sensorEV3_Gyro)
#pragma config(Sensor, S3,     sencolor,       sensorEV3_Color, modeEV3Color_Color)
#pragma config(Motor,  motorA,          plumon,        tmotorEV3_Medium, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          motb,          tmotorEV3_Large, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motorC,          motc,          tmotorEV3_Large, PIDControl, reversed, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////
int giro_fin=0,cont = 0, state = 0, deg = 0,x,y,blue=2,red=5,color,jugando=0;//Definimos variables que nos ayudará para realizar el juego
int juga1,juga2;
int mi_color , color_rival, opcion=1,eleccion=1;//variables de menu
int gato[3][3],jugadas[2];
string col1 = "", col2 = "";
/////////////////////////////////////////////////////////////////////
void menu (int selnum){
	eraseDisplay (); /* Borrar Pantalla */
	switch (selnum) {  //evalua el nuemero de pantalla que visualizara
 		case 0:
 			displayStringAt(30, 120, "Elije los colores:", );
 			displayStringAt(30, 100, "1) Rojo/Azul", );
 			displayStringAt(30, 80, "2) Azul/Rojo", );
			break;
		case 1:
			displayStringAt(3, 120, "Selecciona 1 para jugar", );
			break;
		default:
		break;
	}
}
void lista(int yo,int tu){
	if (yo== 5){
		yo = 2;
		juga1= 2;
		col1 = "rojo";
		tu = 1;
		juga2= 1;
		col2 = "azul";
	}
	else if (tu == 5){
		yo = 1;
		juga1= 1;
		col1 = "azul";
		tu = 2;
		juga2= 2;
		col2 = "rojo";

	}
	displayStringAt(30, 120, "Numeros representativos:", );
 	displayStringAt(30, 100, "Jugador 1: %s = %d",col1,yo );
 	displayStringAt(30, 80, "Jugador 2: %s = %d",col2,tu );
}

int botonApretado(){//informacion del botton que se preciona
	do{
	if(getButtonPress(buttonRight) == 1){
		return 1;
	}
	if(getButtonPress(buttonLeft) == 1){
		return 2;
	}
	if(getButtonPress(buttonEnter) == 1){
		return 3;
	}
	return 0;
	}while(getButtonPress(buttonAny) == 0);
}
void eleccion_color(){
	eraseDisplay ();
		while(eleccion==1){
			displayStringAt(45, 9, "Opcion: %d", opcion);
				if (getButtonPress(buttonAny) == 1){// return verdadero 1 o falso 0 si algun boton es apretado
					switch(botonApretado()){//lamado de funcion potato
						case 1://boton a la derecha
							if(opcion == 2 ){
								opcion = 1;
							} // if case 1
							else{
								opcion++;
							} // else case 1
							break;
							wait1Msec(500);
						case 2://boton a la izquierda
							if (opcion == 1){
								opcion = 2;
							}// if case 2
							else {
								opcion--;
							}// else case 2
							break;
							wait1Msec(500);
						case 3:
							if(opcion == 1){ //boton de el medio
	    					mi_color=5;
	    					color_rival=2;
	    					eleccion=0;
	    				}
	    				else if(opcion ==2){
	    					mi_color = 2;
	    					color_rival= 5;
	   						eleccion = 0;
	   					}
	   					break;
	    		}
	    		menu(0);
	    		displayStringAt(45, 9, "Opcion: %d", opcion);
    			wait1Msec(500);
    		}// if getButtonPress
		}
}
void giro_derecha(int Q){
	motor(motb) = 5;
	motor(motc) = -5;
	while(SensorValue[sengirp] < (Q)) {
			wait1Msec(5);
			continue;
	}
}
void vic(int jugador){
	if (jugador==juga1){
		eraseDisplay();
		displayBigTextLine(5, "YOU WIN!!!");
		sleep(4000);
		stopAllTasks();
	}
	else if (jugador==juga2){
		eraseDisplay();
		displayBigTextLine(5, "YOU LOSE :'c");
		sleep(4000);
		stopAllTasks();
	}
}
void r_g_p(){
	if (gato[0][0] == gato[0][1] && gato[0][1] == gato[0][2] && gato[0][2] != 0 ){
		vic(gato[0][0]);
	}
	else if(gato[1][0] == gato[1][1] && gato[1][1] == gato[1][2] && gato[1][2] != 0 ){
		vic(gato[1][0]);
	}
	else if(gato[2][0] == gato[2][1] && gato[2][1] == gato[2][2] && gato[2][2] != 0 ){
		vic(gato[2][0]);
	}
	else if(gato[0][0] == gato[1][2] && gato[1][2] == gato[2][0] && gato[2][0] != 0 ){
		vic(gato[0][0]);
	}
	else if(gato[0][1] == gato[1][1] && gato[1][1] == gato[2][1] && gato[2][1] != 0 ){
		vic(gato[0][1]);
	}
	else if(gato[0][2] == gato[1][0] && gato[1][0] == gato[2][2] && gato[2][2] != 0 ){
		vic(gato[0][2]);
	}
	else if(gato[0][0] == gato[1][0] && gato[1][0] == gato[2][0] && gato[2][0] != 0 ){
		vic(gato[0][0]);
	}
	else if(gato[0][0] == gato[1][1] && gato[1][1] == gato[2][2] && gato[2][2] != 0 ){
		vic(gato[0][0]);
	}
	else if(gato[0][2] == gato[1][1] && gato[1][1] == gato[2][0] && gato[2][0] != 0 ){
		vic(gato[0][2]);
	}
}

void giro_izquierda(int Q){
	motor(motb) = -5;
	motor(motc) = 5;
	while(SensorValue[sengirp] > (Q)) {
		wait1Msec(5);
		continue;
}
}
void displayTablero() /// MUESTRA EN PANTALLA EL ESTADO ACTUAL DEL TABLERO ///
{
	setLEDColor(ledOrangePulse);
	displayStringAt(20, 100, "	| %d | %d | %d |", gato[0][0], gato[1][2], gato[2][0]);
	displayStringAt(20, 80, "	| %d | %d | %d |", gato[0][1], gato[1][1], gato[2][1]);
	displayStringAt(20, 60, "	| %d | %d | %d |", gato[0][2], gato[1][0], gato[2][2]);
	//sleep(3000);
}
void llenar_gato(){
	for (x = 0; x < 3; x++){ //for para llenar el gato
			for (y = 0; y < 3; y++){
				gato[x][y]=0;
	}
}
}
void pintar(){
	motor(motb)=-10;
	motor(motc)=-10;
	wait1Msec(500);
	motor(motb)=0;
	motor(motc)=0;
	motor(plumon)=10;
	wait1Msec(555);
	motor(plumon)=0;
	int raya=0;
	while(raya!=3){
		motor(motb)=-10;
		motor(motc)=10;
		wait1Msec(500);
		motor(motb)=10;
		motor(motc)=-10;
		wait1Msec(500);
		raya++;
	}
	motor(motb)=0;
	motor(motc)=0;
	motor(plumon)=-10;
	wait1Msec(552.5);
	motor(plumon)=0;
}
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////
task main(){
llenar_gato();
eleccion_color();
lista(mi_color,color_rival);
while(true){
if(getUSDistance(sonic)<50){
giro_fin=0;
state=0;
cont=0;
while (state!= 3){//recorrido
		int color = SensorValue[sencolor];
		if(color == 0) { //Si el sensor no detecta colores, el robot permacerá quieto y luego se reinicia hasta que detecte un color
			cont = 0;
			state = 0;
			motor[motb] = 0; //así funciona por ahora xd (antes = motor(motorB)
			motor(motc) = 0;
			wait1Msec(10);
			continue;
		}
		if (color==blue){//reconocer nuestro color
		gato[state][cont-1] = 1;
		}
		else if (color==red){//reconocer color rival
		gato[state][cont-1] = 2;
		}
		if ((color == 1)&&(cont < 4)){ // Cuando el sensor detecta el color negro, a la variable cont se le suma 1,si cont es menor a 2 el robot sigue avanzando
			motor(motb) = 10;
			motor(motc) = 10;
			cont++;
			wait1Msec(500);
		}
		else { // Si el sensor no detectó ningún color negro sigue avanzando
			motor(motb) = 10;
			motor(motc) = 10;
		}
		if (cont == 4){ //Si el cont es igual a 2 el sensor giroscopio hará que éste gire
			wait1Msec(500);
			resetGyro(sengirp);
			if(state == 0) { // Giro de DERECHA
				motor(motb) = 10;
				motor(motc) = 10;
				wait1Msec(1500);
				giro_derecha(85);
				motor(motb) = -10; //Para reacomodar el robot dentro del sector, ponemos los valores de los motores en negativo para que el robot retroceda
				motor(motc) = -10;
				wait1Msec(1000);
				resetGyro(sengirp);
				while(giro_fin!=1){
					color = SensorValue[sencolor];
					if (color==1){
						motor(motb) = 10;
						motor(motc) = 10;
						wait1Msec(2300);
						giro_derecha(80);
						giro_fin=1;
						motor(motb) = -10;
						motor(motc) = -10;
						wait1Msec(3500);
					}
					else{
						motor(motb)= 10;
						motor(motc)= 10;
					}
				}//while giro_fin
			}
			if(state==1){//Ultimo giro
				motor(motb) = 10;
				motor(motc) = 10;
				wait1Msec(2500);
				giro_izquierda(-90);
				motor(motb) = 5;
				motor(motc) = 5;
				wait1Msec(400);
				motor(motb) = -5;
				motor(motc) = 5;
				giro_izquierda(-170);
				motor(motb) = -10;
				motor(motc) = -10;
				wait1Msec(2500);
				}//giro izquierda
			state++;
			cont=0;
		}//if cont
	eraseDisplay();
	displayTablero();
	}//while recorrido
motor(motb)=0;
motor(motc)=0;
r_g_p();
resetGyro(sengirp);
motor(motb)=10;
motor(motc)=10;
wait1Msec(1500);
motor(motb)=5;
motor(motc)=-5;
giro_derecha(90);
motor(motb)=10;
motor(motc)=10;
wait1Msec(1350);
giro_derecha(176);
motor(motb)=-10;
motor(motc)=-10;
wait1Msec(4000);
state--;
giro_fin=0;
cont=4;
jugando=0;
while(state != -1){//regreso
		color = SensorValue[sencolor];
		if ((color == 1)&&(cont > 0)){
			motor(motb) = 10;
			motor(motc) = 10;
			cont--;
			wait1Msec(500);
		}
		else{
			motor(motb)=10;
			motor(motc)=10;
		}
		if (state==0&&cont-1==0&&jugando!=1){
			motor(motb)=0;
			motor(motc)=0;
			pintar();
			jugando++;
		}
		if (cont == 0){
			wait1Msec(500);
			resetGyro(sengirp);
			if(state == 2) {
				motor(motb) = 10;
				motor(motc) = 10;
				wait1Msec(1500);
				motor(motb) = 5;
				motor(motc) = -5;
				giro_derecha(90);
				motor(motb) = -10;
				motor(motc) = -10;
				wait1Msec(1000);
				resetGyro(sengirp);
				while(giro_fin!=1){
					color = SensorValue[sencolor];
					if (color==1){
						motor(motb) = 10;
						motor(motc) = 10;
						wait1Msec(2600);
						motor(motb) = 5;
						motor(motc) = -5;
						giro_derecha(80);
						giro_fin=1;
						motor(motb) = -10;
						motor(motc) = -10;
						wait1Msec(3500);
					}
					else{
						motor(motb)= 10;
						motor(motc)= 10;

					}
				}//giro_fin
			}//state 2
			if(state==1){//Ultimo giro
				motor(motb) = 10;
				motor(motc) = 10;
				wait1Msec(2500);
				motor(motb) = -5;
				motor(motc) = 5;
				giro_izquierda(-90);
				motor(motb) = 5;
				motor(motc) = 5;
				wait1Msec(500);
				motor(motb) = -5;
				motor(motc) = 5;
				giro_izquierda(-175);
				motor(motb) = -10;
				motor(motc) = -10;
				wait1Msec(2500);
			}
			state--;
			cont=4;
	}//if cont
}
resetGyro(sengirp);
motor(motb)=10;
motor(motc)=10;
wait1Msec(1500);
motor(motb)=5;
motor(motc)=-5;
giro_derecha(90);
motor(motb)=10;
motor(motc)=10;
wait1Msec(1350);
giro_derecha(176);
motor(motb)=-10;
motor(motc)=-10;
wait1Msec(8000);
motor(motb)=0;
motor(motc)=0;
}
else{
	wait1Msec(500);
}
}
}
